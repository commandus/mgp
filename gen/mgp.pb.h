// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mgp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mgp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mgp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
//-- autogenerated by tools/generate-code.ps1. 2023-02-19 01:29 --
#include <odb/core.hxx>
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mgp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mgp_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mgp_2eproto;
namespace mgp {
class Attribute;
struct AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class Credentials;
struct CredentialsDefaultTypeInternal;
extern CredentialsDefaultTypeInternal _Credentials_default_instance_;
class Employee;
struct EmployeeDefaultTypeInternal;
extern EmployeeDefaultTypeInternal _Employee_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class InventoryListRequest;
struct InventoryListRequestDefaultTypeInternal;
extern InventoryListRequestDefaultTypeInternal _InventoryListRequest_default_instance_;
class InventoryListResponse;
struct InventoryListResponseDefaultTypeInternal;
extern InventoryListResponseDefaultTypeInternal _InventoryListResponse_default_instance_;
class ListRequest;
struct ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class MediaFile;
struct MediaFileDefaultTypeInternal;
extern MediaFileDefaultTypeInternal _MediaFile_default_instance_;
class OperationResponse;
struct OperationResponseDefaultTypeInternal;
extern OperationResponseDefaultTypeInternal _OperationResponse_default_instance_;
class Org;
struct OrgDefaultTypeInternal;
extern OrgDefaultTypeInternal _Org_default_instance_;
class Person;
struct PersonDefaultTypeInternal;
extern PersonDefaultTypeInternal _Person_default_instance_;
class SearchRequest;
struct SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace mgp
PROTOBUF_NAMESPACE_OPEN
template<> ::mgp::Attribute* Arena::CreateMaybeMessage<::mgp::Attribute>(Arena*);
template<> ::mgp::Credentials* Arena::CreateMaybeMessage<::mgp::Credentials>(Arena*);
template<> ::mgp::Employee* Arena::CreateMaybeMessage<::mgp::Employee>(Arena*);
template<> ::mgp::Inventory* Arena::CreateMaybeMessage<::mgp::Inventory>(Arena*);
template<> ::mgp::InventoryListRequest* Arena::CreateMaybeMessage<::mgp::InventoryListRequest>(Arena*);
template<> ::mgp::InventoryListResponse* Arena::CreateMaybeMessage<::mgp::InventoryListResponse>(Arena*);
template<> ::mgp::ListRequest* Arena::CreateMaybeMessage<::mgp::ListRequest>(Arena*);
template<> ::mgp::MediaFile* Arena::CreateMaybeMessage<::mgp::MediaFile>(Arena*);
template<> ::mgp::OperationResponse* Arena::CreateMaybeMessage<::mgp::OperationResponse>(Arena*);
template<> ::mgp::Org* Arena::CreateMaybeMessage<::mgp::Org>(Arena*);
template<> ::mgp::Person* Arena::CreateMaybeMessage<::mgp::Person>(Arena*);
template<> ::mgp::SearchRequest* Arena::CreateMaybeMessage<::mgp::SearchRequest>(Arena*);
template<> ::mgp::User* Arena::CreateMaybeMessage<::mgp::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mgp {

// ===================================================================

class Attribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.Attribute) */ {
 public:
  inline Attribute() : Attribute(nullptr) {}
  ~Attribute() override;
  explicit constexpr Attribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribute(const Attribute& from);
  Attribute(Attribute&& from) noexcept
    : Attribute() {
    *this = ::std::move(from);
  }

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribute& operator=(Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
               &_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Attribute& a, Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribute* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attribute* New() const final {
    return new Attribute();
  }

  Attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Attribute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.Attribute";
  }
  protected:
  explicit Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kValueFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.Attribute)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.Attribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class OperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.OperationResponse) */ {
 public:
  inline OperationResponse() : OperationResponse(nullptr) {}
  ~OperationResponse() override;
  explicit constexpr OperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationResponse(const OperationResponse& from);
  OperationResponse(OperationResponse&& from) noexcept
    : OperationResponse() {
    *this = ::std::move(from);
  }

  inline OperationResponse& operator=(const OperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationResponse& operator=(OperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationResponse* internal_default_instance() {
    return reinterpret_cast<const OperationResponse*>(
               &_OperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OperationResponse& a, OperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperationResponse* New() const final {
    return new OperationResponse();
  }

  OperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OperationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.OperationResponse";
  }
  protected:
  explicit OperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // uint64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.OperationResponse)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.OperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class ListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {}
  ~ListRequest() override;
  explicit constexpr ListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRequest(const ListRequest& from);
  ListRequest(ListRequest&& from) noexcept
    : ListRequest() {
    *this = ::std::move(from);
  }

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
               &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListRequest& a, ListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRequest* New() const final {
    return new ListRequest();
  }

  ListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.ListRequest";
  }
  protected:
  explicit ListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // uint32 start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::uint32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 size = 2;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.ListRequest)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.ListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class SearchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {}
  ~SearchRequest() override;
  explicit constexpr SearchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchRequest(const SearchRequest& from);
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchRequest* New() const final {
    return new SearchRequest();
  }

  SearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.SearchRequest";
  }
  protected:
  explicit SearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 1,
    kListrequestFieldNumber = 2,
  };
  // repeated .mgp.Attribute attributes = 1;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mgp::Attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Attribute >*
      mutable_attributes();
  private:
  const ::mgp::Attribute& _internal_attributes(int index) const;
  ::mgp::Attribute* _internal_add_attributes();
  public:
  const ::mgp::Attribute& attributes(int index) const;
  ::mgp::Attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Attribute >&
      attributes() const;

  // .mgp.ListRequest listrequest = 2;
  bool has_listrequest() const;
  private:
  bool _internal_has_listrequest() const;
  public:
  void clear_listrequest();
  const ::mgp::ListRequest& listrequest() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::ListRequest* release_listrequest();
  ::mgp::ListRequest* mutable_listrequest();
  void set_allocated_listrequest(::mgp::ListRequest* listrequest);
  private:
  const ::mgp::ListRequest& _internal_listrequest() const;
  ::mgp::ListRequest* _internal_mutable_listrequest();
  public:
  void unsafe_arena_set_allocated_listrequest(
      ::mgp::ListRequest* listrequest);
  ::mgp::ListRequest* unsafe_arena_release_listrequest();

  // @@protoc_insertion_point(--class_scope:mgp.SearchRequest)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.SearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Attribute > attributes_;
  ::mgp::ListRequest* listrequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class Credentials final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.Credentials) */ {
 public:
  inline Credentials() : Credentials(nullptr) {}
  ~Credentials() override;
  explicit constexpr Credentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Credentials(const Credentials& from);
  Credentials(Credentials&& from) noexcept
    : Credentials() {
    *this = ::std::move(from);
  }

  inline Credentials& operator=(const Credentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline Credentials& operator=(Credentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Credentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const Credentials* internal_default_instance() {
    return reinterpret_cast<const Credentials*>(
               &_Credentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Credentials& a, Credentials& b) {
    a.Swap(&b);
  }
  inline void Swap(Credentials* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Credentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Credentials* New() const final {
    return new Credentials();
  }

  Credentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Credentials>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Credentials& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Credentials& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Credentials* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.Credentials";
  }
  protected:
  explicit Credentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMkFieldNumber = 5,
    kMvFieldNumber = 6,
    kIdFieldNumber = 1,
    kStartFieldNumber = 2,
    kFinishFieldNumber = 3,
    kLastloginFieldNumber = 4,
  };
  // string mk = 5;
  void clear_mk();
  const std::string& mk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mk();
  PROTOBUF_MUST_USE_RESULT std::string* release_mk();
  void set_allocated_mk(std::string* mk);
  private:
  const std::string& _internal_mk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mk(const std::string& value);
  std::string* _internal_mutable_mk();
  public:

  // string mv = 6;
  void clear_mv();
  const std::string& mv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mv();
  PROTOBUF_MUST_USE_RESULT std::string* release_mv();
  void set_allocated_mv(std::string* mv);
  private:
  const std::string& _internal_mv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mv(const std::string& value);
  std::string* _internal_mutable_mv();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 start = 2;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::uint32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 finish = 3;
  void clear_finish();
  ::PROTOBUF_NAMESPACE_ID::uint32 finish() const;
  void set_finish(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_finish() const;
  void _internal_set_finish(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 lastlogin = 4;
  void clear_lastlogin();
  ::PROTOBUF_NAMESPACE_ID::uint32 lastlogin() const;
  void set_lastlogin(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lastlogin() const;
  void _internal_set_lastlogin(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.Credentials)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.Credentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mv_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_;
  ::PROTOBUF_NAMESPACE_ID::uint32 finish_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lastlogin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return new User();
  }

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCnFieldNumber = 2,
    kCredentialsFieldNumber = 3,
    kIdFieldNumber = 1,
    kRoleFieldNumber = 4,
  };
  // string cn = 2;
  void clear_cn();
  const std::string& cn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cn();
  PROTOBUF_MUST_USE_RESULT std::string* release_cn();
  void set_allocated_cn(std::string* cn);
  private:
  const std::string& _internal_cn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cn(const std::string& value);
  std::string* _internal_mutable_cn();
  public:

  // .mgp.Credentials credentials = 3;
  bool has_credentials() const;
  private:
  bool _internal_has_credentials() const;
  public:
  void clear_credentials();
  const ::mgp::Credentials& credentials() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::Credentials* release_credentials();
  ::mgp::Credentials* mutable_credentials();
  void set_allocated_credentials(::mgp::Credentials* credentials);
  private:
  const ::mgp::Credentials& _internal_credentials() const;
  ::mgp::Credentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::mgp::Credentials* credentials);
  ::mgp::Credentials* unsafe_arena_release_credentials();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 role = 4;
  void clear_role();
  ::PROTOBUF_NAMESPACE_ID::uint32 role() const;
  void set_role(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_role() const;
  void _internal_set_role(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.User)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cn_;
  ::mgp::Credentials* credentials_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class MediaFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.MediaFile) */ {
 public:
  inline MediaFile() : MediaFile(nullptr) {}
  ~MediaFile() override;
  explicit constexpr MediaFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaFile(const MediaFile& from);
  MediaFile(MediaFile&& from) noexcept
    : MediaFile() {
    *this = ::std::move(from);
  }

  inline MediaFile& operator=(const MediaFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaFile& operator=(MediaFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaFile* internal_default_instance() {
    return reinterpret_cast<const MediaFile*>(
               &_MediaFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MediaFile& a, MediaFile& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaFile* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaFile* New() const final {
    return new MediaFile();
  }

  MediaFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MediaFile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaFile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.MediaFile";
  }
  protected:
  explicit MediaFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentTypeFieldNumber = 2,
    kUriFieldNumber = 3,
    kDataFieldNumber = 5,
    kIdFieldNumber = 1,
    kContentLengthFieldNumber = 4,
    kTagFieldNumber = 6,
  };
  // string content_type = 2;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // string uri = 3;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_MUST_USE_RESULT std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 content_length = 4;
  void clear_content_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 content_length() const;
  void set_content_length(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_content_length() const;
  void _internal_set_content_length(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 tag = 6;
  void clear_tag();
  ::PROTOBUF_NAMESPACE_ID::uint32 tag() const;
  void set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tag() const;
  void _internal_set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.MediaFile)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.MediaFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 content_length_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class Person final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.Person) */ {
 public:
  inline Person() : Person(nullptr) {}
  ~Person() override;
  explicit constexpr Person(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Person(const Person& from);
  Person(Person&& from) noexcept
    : Person() {
    *this = ::std::move(from);
  }

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }
  inline Person& operator=(Person&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Person& default_instance() {
    return *internal_default_instance();
  }
  static inline const Person* internal_default_instance() {
    return reinterpret_cast<const Person*>(
               &_Person_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Person& a, Person& b) {
    a.Swap(&b);
  }
  inline void Swap(Person* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Person* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Person* New() const final {
    return new Person();
  }

  Person* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Person>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Person& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Person& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Person* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.Person";
  }
  protected:
  explicit Person(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediasFieldNumber = 13,
    kFirstNameFieldNumber = 2,
    kLastNameFieldNumber = 3,
    kMiddleNameFieldNumber = 4,
    kPrefixFieldNumber = 5,
    kDocumentTypeFieldNumber = 7,
    kDocumentFieldNumber = 8,
    kPhoneMobileFieldNumber = 9,
    kEmailFieldNumber = 10,
    kIdFieldNumber = 1,
    kBirthdayFieldNumber = 6,
    kGenderFieldNumber = 11,
    kTagFieldNumber = 12,
  };
  // repeated .mgp.MediaFile medias = 13;
  int medias_size() const;
  private:
  int _internal_medias_size() const;
  public:
  void clear_medias();
  ::mgp::MediaFile* mutable_medias(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
      mutable_medias();
  private:
  const ::mgp::MediaFile& _internal_medias(int index) const;
  ::mgp::MediaFile* _internal_add_medias();
  public:
  const ::mgp::MediaFile& medias(int index) const;
  ::mgp::MediaFile* add_medias();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
      medias() const;

  // string first_name = 2;
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // string last_name = 3;
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // string middle_name = 4;
  void clear_middle_name();
  const std::string& middle_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_middle_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_middle_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_middle_name();
  void set_allocated_middle_name(std::string* middle_name);
  private:
  const std::string& _internal_middle_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_middle_name(const std::string& value);
  std::string* _internal_mutable_middle_name();
  public:

  // string prefix = 5;
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_MUST_USE_RESULT std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string document_type = 7;
  void clear_document_type();
  const std::string& document_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_document_type();
  void set_allocated_document_type(std::string* document_type);
  private:
  const std::string& _internal_document_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_type(const std::string& value);
  std::string* _internal_mutable_document_type();
  public:

  // string document = 8;
  void clear_document();
  const std::string& document() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document();
  PROTOBUF_MUST_USE_RESULT std::string* release_document();
  void set_allocated_document(std::string* document);
  private:
  const std::string& _internal_document() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document(const std::string& value);
  std::string* _internal_mutable_document();
  public:

  // string phone_mobile = 9;
  void clear_phone_mobile();
  const std::string& phone_mobile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone_mobile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone_mobile();
  PROTOBUF_MUST_USE_RESULT std::string* release_phone_mobile();
  void set_allocated_phone_mobile(std::string* phone_mobile);
  private:
  const std::string& _internal_phone_mobile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_mobile(const std::string& value);
  std::string* _internal_mutable_phone_mobile();
  public:

  // string email = 10;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_MUST_USE_RESULT std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 birthday = 6;
  void clear_birthday();
  ::PROTOBUF_NAMESPACE_ID::uint32 birthday() const;
  void set_birthday(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_birthday() const;
  void _internal_set_birthday(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 gender = 11;
  void clear_gender();
  ::PROTOBUF_NAMESPACE_ID::uint32 gender() const;
  void set_gender(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_gender() const;
  void _internal_set_gender(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 tag = 12;
  void clear_tag();
  ::PROTOBUF_NAMESPACE_ID::uint32 tag() const;
  void set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tag() const;
  void _internal_set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.Person)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.Person)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile > medias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr middle_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_mobile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 birthday_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gender_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class Employee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.Employee) */ {
 public:
  inline Employee() : Employee(nullptr) {}
  ~Employee() override;
  explicit constexpr Employee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Employee(const Employee& from);
  Employee(Employee&& from) noexcept
    : Employee() {
    *this = ::std::move(from);
  }

  inline Employee& operator=(const Employee& from) {
    CopyFrom(from);
    return *this;
  }
  inline Employee& operator=(Employee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Employee& default_instance() {
    return *internal_default_instance();
  }
  static inline const Employee* internal_default_instance() {
    return reinterpret_cast<const Employee*>(
               &_Employee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Employee& a, Employee& b) {
    a.Swap(&b);
  }
  inline void Swap(Employee* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Employee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Employee* New() const final {
    return new Employee();
  }

  Employee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Employee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Employee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Employee& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Employee* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.Employee";
  }
  protected:
  explicit Employee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediasFieldNumber = 6,
    kNameFieldNumber = 3,
    kPersonFieldNumber = 4,
    kUserFieldNumber = 5,
    kIdFieldNumber = 1,
    kRoleNumberFieldNumber = 2,
  };
  // repeated .mgp.MediaFile medias = 6;
  int medias_size() const;
  private:
  int _internal_medias_size() const;
  public:
  void clear_medias();
  ::mgp::MediaFile* mutable_medias(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
      mutable_medias();
  private:
  const ::mgp::MediaFile& _internal_medias(int index) const;
  ::mgp::MediaFile* _internal_add_medias();
  public:
  const ::mgp::MediaFile& medias(int index) const;
  ::mgp::MediaFile* add_medias();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
      medias() const;

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mgp.Person person = 4;
  bool has_person() const;
  private:
  bool _internal_has_person() const;
  public:
  void clear_person();
  const ::mgp::Person& person() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::Person* release_person();
  ::mgp::Person* mutable_person();
  void set_allocated_person(::mgp::Person* person);
  private:
  const ::mgp::Person& _internal_person() const;
  ::mgp::Person* _internal_mutable_person();
  public:
  void unsafe_arena_set_allocated_person(
      ::mgp::Person* person);
  ::mgp::Person* unsafe_arena_release_person();

  // .mgp.User user = 5;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::mgp::User& user() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::User* release_user();
  ::mgp::User* mutable_user();
  void set_allocated_user(::mgp::User* user);
  private:
  const ::mgp::User& _internal_user() const;
  ::mgp::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::mgp::User* user);
  ::mgp::User* unsafe_arena_release_user();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 role_number = 2;
  void clear_role_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 role_number() const;
  void set_role_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_role_number() const;
  void _internal_set_role_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.Employee)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.Employee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile > medias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mgp::Person* person_;
  ::mgp::User* user_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 role_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class Org final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.Org) */ {
 public:
  inline Org() : Org(nullptr) {}
  ~Org() override;
  explicit constexpr Org(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Org(const Org& from);
  Org(Org&& from) noexcept
    : Org() {
    *this = ::std::move(from);
  }

  inline Org& operator=(const Org& from) {
    CopyFrom(from);
    return *this;
  }
  inline Org& operator=(Org&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Org& default_instance() {
    return *internal_default_instance();
  }
  static inline const Org* internal_default_instance() {
    return reinterpret_cast<const Org*>(
               &_Org_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Org& a, Org& b) {
    a.Swap(&b);
  }
  inline void Swap(Org* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Org* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Org* New() const final {
    return new Org();
  }

  Org* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Org>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Org& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Org& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Org* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.Org";
  }
  protected:
  explicit Org(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediasFieldNumber = 4,
    kNameFieldNumber = 2,
    kManagerFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .mgp.MediaFile medias = 4;
  int medias_size() const;
  private:
  int _internal_medias_size() const;
  public:
  void clear_medias();
  ::mgp::MediaFile* mutable_medias(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
      mutable_medias();
  private:
  const ::mgp::MediaFile& _internal_medias(int index) const;
  ::mgp::MediaFile* _internal_add_medias();
  public:
  const ::mgp::MediaFile& medias(int index) const;
  ::mgp::MediaFile* add_medias();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
      medias() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mgp.Employee manager = 3;
  bool has_manager() const;
  private:
  bool _internal_has_manager() const;
  public:
  void clear_manager();
  const ::mgp::Employee& manager() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::Employee* release_manager();
  ::mgp::Employee* mutable_manager();
  void set_allocated_manager(::mgp::Employee* manager);
  private:
  const ::mgp::Employee& _internal_manager() const;
  ::mgp::Employee* _internal_mutable_manager();
  public:
  void unsafe_arena_set_allocated_manager(
      ::mgp::Employee* manager);
  ::mgp::Employee* unsafe_arena_release_manager();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.Org)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.Org)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile > medias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mgp::Employee* manager_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class Inventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  explicit constexpr Inventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inventory* New() const final {
    return new Inventory();
  }

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Inventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediasFieldNumber = 5,
    kNameFieldNumber = 4,
    kOrgFieldNumber = 2,
    kIdFieldNumber = 1,
    kInventoryNumberFieldNumber = 3,
  };
  // repeated .mgp.MediaFile medias = 5;
  int medias_size() const;
  private:
  int _internal_medias_size() const;
  public:
  void clear_medias();
  ::mgp::MediaFile* mutable_medias(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
      mutable_medias();
  private:
  const ::mgp::MediaFile& _internal_medias(int index) const;
  ::mgp::MediaFile* _internal_add_medias();
  public:
  const ::mgp::MediaFile& medias(int index) const;
  ::mgp::MediaFile* add_medias();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
      medias() const;

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mgp.Org org = 2;
  bool has_org() const;
  private:
  bool _internal_has_org() const;
  public:
  void clear_org();
  const ::mgp::Org& org() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::Org* release_org();
  ::mgp::Org* mutable_org();
  void set_allocated_org(::mgp::Org* org);
  private:
  const ::mgp::Org& _internal_org() const;
  ::mgp::Org* _internal_mutable_org();
  public:
  void unsafe_arena_set_allocated_org(
      ::mgp::Org* org);
  ::mgp::Org* unsafe_arena_release_org();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 inventory_number = 3;
  void clear_inventory_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 inventory_number() const;
  void set_inventory_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_inventory_number() const;
  void _internal_set_inventory_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(--class_scope:mgp.Inventory)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile > medias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mgp::Org* org_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 inventory_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class InventoryListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.InventoryListRequest) */ {
 public:
  inline InventoryListRequest() : InventoryListRequest(nullptr) {}
  ~InventoryListRequest() override;
  explicit constexpr InventoryListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryListRequest(const InventoryListRequest& from);
  InventoryListRequest(InventoryListRequest&& from) noexcept
    : InventoryListRequest() {
    *this = ::std::move(from);
  }

  inline InventoryListRequest& operator=(const InventoryListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryListRequest& operator=(InventoryListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryListRequest* internal_default_instance() {
    return reinterpret_cast<const InventoryListRequest*>(
               &_InventoryListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InventoryListRequest& a, InventoryListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryListRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InventoryListRequest* New() const final {
    return new InventoryListRequest();
  }

  InventoryListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InventoryListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InventoryListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.InventoryListRequest";
  }
  protected:
  explicit InventoryListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryFieldNumber = 1,
    kListrequestFieldNumber = 2,
  };
  // .mgp.Inventory inventory = 1;
  bool has_inventory() const;
  private:
  bool _internal_has_inventory() const;
  public:
  void clear_inventory();
  const ::mgp::Inventory& inventory() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::Inventory* release_inventory();
  ::mgp::Inventory* mutable_inventory();
  void set_allocated_inventory(::mgp::Inventory* inventory);
  private:
  const ::mgp::Inventory& _internal_inventory() const;
  ::mgp::Inventory* _internal_mutable_inventory();
  public:
  void unsafe_arena_set_allocated_inventory(
      ::mgp::Inventory* inventory);
  ::mgp::Inventory* unsafe_arena_release_inventory();

  // .mgp.ListRequest listrequest = 2;
  bool has_listrequest() const;
  private:
  bool _internal_has_listrequest() const;
  public:
  void clear_listrequest();
  const ::mgp::ListRequest& listrequest() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::ListRequest* release_listrequest();
  ::mgp::ListRequest* mutable_listrequest();
  void set_allocated_listrequest(::mgp::ListRequest* listrequest);
  private:
  const ::mgp::ListRequest& _internal_listrequest() const;
  ::mgp::ListRequest* _internal_mutable_listrequest();
  public:
  void unsafe_arena_set_allocated_listrequest(
      ::mgp::ListRequest* listrequest);
  ::mgp::ListRequest* unsafe_arena_release_listrequest();

  // @@protoc_insertion_point(--class_scope:mgp.InventoryListRequest)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.InventoryListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mgp::Inventory* inventory_;
  ::mgp::ListRequest* listrequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// -------------------------------------------------------------------

class InventoryListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mgp.InventoryListResponse) */ {
 public:
  inline InventoryListResponse() : InventoryListResponse(nullptr) {}
  ~InventoryListResponse() override;
  explicit constexpr InventoryListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryListResponse(const InventoryListResponse& from);
  InventoryListResponse(InventoryListResponse&& from) noexcept
    : InventoryListResponse() {
    *this = ::std::move(from);
  }

  inline InventoryListResponse& operator=(const InventoryListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryListResponse& operator=(InventoryListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryListResponse* internal_default_instance() {
    return reinterpret_cast<const InventoryListResponse*>(
               &_InventoryListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InventoryListResponse& a, InventoryListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryListResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InventoryListResponse* New() const final {
    return new InventoryListResponse();
  }

  InventoryListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InventoryListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InventoryListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mgp.InventoryListResponse";
  }
  protected:
  explicit InventoryListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // repeated .mgp.Inventory inventory = 2;
  int inventory_size() const;
  private:
  int _internal_inventory_size() const;
  public:
  void clear_inventory();
  ::mgp::Inventory* mutable_inventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Inventory >*
      mutable_inventory();
  private:
  const ::mgp::Inventory& _internal_inventory(int index) const;
  ::mgp::Inventory* _internal_add_inventory();
  public:
  const ::mgp::Inventory& inventory(int index) const;
  ::mgp::Inventory* add_inventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Inventory >&
      inventory() const;

  // .mgp.OperationResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::mgp::OperationResponse& response() const;
  PROTOBUF_MUST_USE_RESULT ::mgp::OperationResponse* release_response();
  ::mgp::OperationResponse* mutable_response();
  void set_allocated_response(::mgp::OperationResponse* response);
  private:
  const ::mgp::OperationResponse& _internal_response() const;
  ::mgp::OperationResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::mgp::OperationResponse* response);
  ::mgp::OperationResponse* unsafe_arena_release_response();

  // @@protoc_insertion_point(--class_scope:mgp.InventoryListResponse)
 private:
  friend class odb::access;
  // @@prepare-pb-odb-class(mgp.InventoryListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Inventory > inventory_;
  ::mgp::OperationResponse* response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mgp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Attribute

// uint64 id = 1;
inline void Attribute::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Attribute::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Attribute::id() const {
  // @@protoc_insertion_point(field_get:mgp.Attribute.id)
  return _internal_id();
}
inline void Attribute::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Attribute::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.Attribute.id)
}

// string name = 2;
inline void Attribute::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Attribute::name() const {
  // @@protoc_insertion_point(field_get:mgp.Attribute.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribute::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Attribute.name)
}
inline std::string* Attribute::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mgp.Attribute.name)
  return _s;
}
inline const std::string& Attribute::_internal_name() const {
  return name_.Get();
}
inline void Attribute::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Attribute::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Attribute::release_name() {
  // @@protoc_insertion_point(field_release:mgp.Attribute.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Attribute::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Attribute.name)
}

// string value = 3;
inline void Attribute::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Attribute::value() const {
  // @@protoc_insertion_point(field_get:mgp.Attribute.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribute::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Attribute.value)
}
inline std::string* Attribute::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:mgp.Attribute.value)
  return _s;
}
inline const std::string& Attribute::_internal_value() const {
  return value_.Get();
}
inline void Attribute::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Attribute::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Attribute::release_value() {
  // @@protoc_insertion_point(field_release:mgp.Attribute.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Attribute::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Attribute.value)
}

// -------------------------------------------------------------------

// OperationResponse

// int32 code = 1;
inline void OperationResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OperationResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OperationResponse::code() const {
  // @@protoc_insertion_point(field_get:mgp.OperationResponse.code)
  return _internal_code();
}
inline void OperationResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void OperationResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:mgp.OperationResponse.code)
}

// uint64 id = 2;
inline void OperationResponse::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OperationResponse::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OperationResponse::id() const {
  // @@protoc_insertion_point(field_get:mgp.OperationResponse.id)
  return _internal_id();
}
inline void OperationResponse::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void OperationResponse::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.OperationResponse.id)
}

// -------------------------------------------------------------------

// ListRequest

// uint32 start = 1;
inline void ListRequest::clear_start() {
  start_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRequest::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRequest::start() const {
  // @@protoc_insertion_point(field_get:mgp.ListRequest.start)
  return _internal_start();
}
inline void ListRequest::_internal_set_start(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  start_ = value;
}
inline void ListRequest::set_start(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:mgp.ListRequest.start)
}

// uint32 size = 2;
inline void ListRequest::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRequest::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRequest::size() const {
  // @@protoc_insertion_point(field_get:mgp.ListRequest.size)
  return _internal_size();
}
inline void ListRequest::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
}
inline void ListRequest::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:mgp.ListRequest.size)
}

// -------------------------------------------------------------------

// SearchRequest

// repeated .mgp.Attribute attributes = 1;
inline int SearchRequest::_internal_attributes_size() const {
  return attributes_.size();
}
inline int SearchRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline void SearchRequest::clear_attributes() {
  attributes_.Clear();
}
inline ::mgp::Attribute* SearchRequest::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mgp.SearchRequest.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Attribute >*
SearchRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mgp.SearchRequest.attributes)
  return &attributes_;
}
inline const ::mgp::Attribute& SearchRequest::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mgp::Attribute& SearchRequest::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mgp.SearchRequest.attributes)
  return _internal_attributes(index);
}
inline ::mgp::Attribute* SearchRequest::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mgp::Attribute* SearchRequest::add_attributes() {
  ::mgp::Attribute* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:mgp.SearchRequest.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Attribute >&
SearchRequest::attributes() const {
  // @@protoc_insertion_point(field_list:mgp.SearchRequest.attributes)
  return attributes_;
}

// .mgp.ListRequest listrequest = 2;
inline bool SearchRequest::_internal_has_listrequest() const {
  return this != internal_default_instance() && listrequest_ != nullptr;
}
inline bool SearchRequest::has_listrequest() const {
  return _internal_has_listrequest();
}
inline void SearchRequest::clear_listrequest() {
  if (GetArenaForAllocation() == nullptr && listrequest_ != nullptr) {
    delete listrequest_;
  }
  listrequest_ = nullptr;
}
inline const ::mgp::ListRequest& SearchRequest::_internal_listrequest() const {
  const ::mgp::ListRequest* p = listrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::ListRequest&>(
      ::mgp::_ListRequest_default_instance_);
}
inline const ::mgp::ListRequest& SearchRequest::listrequest() const {
  // @@protoc_insertion_point(field_get:mgp.SearchRequest.listrequest)
  return _internal_listrequest();
}
inline void SearchRequest::unsafe_arena_set_allocated_listrequest(
    ::mgp::ListRequest* listrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(listrequest_);
  }
  listrequest_ = listrequest;
  if (listrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.SearchRequest.listrequest)
}
inline ::mgp::ListRequest* SearchRequest::release_listrequest() {
  
  ::mgp::ListRequest* temp = listrequest_;
  listrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::ListRequest* SearchRequest::unsafe_arena_release_listrequest() {
  // @@protoc_insertion_point(field_release:mgp.SearchRequest.listrequest)
  
  ::mgp::ListRequest* temp = listrequest_;
  listrequest_ = nullptr;
  return temp;
}
inline ::mgp::ListRequest* SearchRequest::_internal_mutable_listrequest() {
  
  if (listrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::ListRequest>(GetArenaForAllocation());
    listrequest_ = p;
  }
  return listrequest_;
}
inline ::mgp::ListRequest* SearchRequest::mutable_listrequest() {
  ::mgp::ListRequest* _msg = _internal_mutable_listrequest();
  // @@protoc_insertion_point(field_mutable:mgp.SearchRequest.listrequest)
  return _msg;
}
inline void SearchRequest::set_allocated_listrequest(::mgp::ListRequest* listrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete listrequest_;
  }
  if (listrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::ListRequest>::GetOwningArena(listrequest);
    if (message_arena != submessage_arena) {
      listrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, listrequest, submessage_arena);
    }
    
  } else {
    
  }
  listrequest_ = listrequest;
  // @@protoc_insertion_point(field_set_allocated:mgp.SearchRequest.listrequest)
}

// -------------------------------------------------------------------

// Credentials

// uint64 id = 1;
inline void Credentials::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Credentials::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Credentials::id() const {
  // @@protoc_insertion_point(field_get:mgp.Credentials.id)
  return _internal_id();
}
inline void Credentials::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Credentials::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.Credentials.id)
}

// uint32 start = 2;
inline void Credentials::clear_start() {
  start_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Credentials::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Credentials::start() const {
  // @@protoc_insertion_point(field_get:mgp.Credentials.start)
  return _internal_start();
}
inline void Credentials::_internal_set_start(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  start_ = value;
}
inline void Credentials::set_start(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:mgp.Credentials.start)
}

// uint32 finish = 3;
inline void Credentials::clear_finish() {
  finish_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Credentials::_internal_finish() const {
  return finish_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Credentials::finish() const {
  // @@protoc_insertion_point(field_get:mgp.Credentials.finish)
  return _internal_finish();
}
inline void Credentials::_internal_set_finish(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  finish_ = value;
}
inline void Credentials::set_finish(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_finish(value);
  // @@protoc_insertion_point(field_set:mgp.Credentials.finish)
}

// uint32 lastlogin = 4;
inline void Credentials::clear_lastlogin() {
  lastlogin_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Credentials::_internal_lastlogin() const {
  return lastlogin_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Credentials::lastlogin() const {
  // @@protoc_insertion_point(field_get:mgp.Credentials.lastlogin)
  return _internal_lastlogin();
}
inline void Credentials::_internal_set_lastlogin(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lastlogin_ = value;
}
inline void Credentials::set_lastlogin(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lastlogin(value);
  // @@protoc_insertion_point(field_set:mgp.Credentials.lastlogin)
}

// string mk = 5;
inline void Credentials::clear_mk() {
  mk_.ClearToEmpty();
}
inline const std::string& Credentials::mk() const {
  // @@protoc_insertion_point(field_get:mgp.Credentials.mk)
  return _internal_mk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Credentials::set_mk(ArgT0&& arg0, ArgT... args) {
 
 mk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Credentials.mk)
}
inline std::string* Credentials::mutable_mk() {
  std::string* _s = _internal_mutable_mk();
  // @@protoc_insertion_point(field_mutable:mgp.Credentials.mk)
  return _s;
}
inline const std::string& Credentials::_internal_mk() const {
  return mk_.Get();
}
inline void Credentials::_internal_set_mk(const std::string& value) {
  
  mk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Credentials::_internal_mutable_mk() {
  
  return mk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Credentials::release_mk() {
  // @@protoc_insertion_point(field_release:mgp.Credentials.mk)
  return mk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Credentials::set_allocated_mk(std::string* mk) {
  if (mk != nullptr) {
    
  } else {
    
  }
  mk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Credentials.mk)
}

// string mv = 6;
inline void Credentials::clear_mv() {
  mv_.ClearToEmpty();
}
inline const std::string& Credentials::mv() const {
  // @@protoc_insertion_point(field_get:mgp.Credentials.mv)
  return _internal_mv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Credentials::set_mv(ArgT0&& arg0, ArgT... args) {
 
 mv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Credentials.mv)
}
inline std::string* Credentials::mutable_mv() {
  std::string* _s = _internal_mutable_mv();
  // @@protoc_insertion_point(field_mutable:mgp.Credentials.mv)
  return _s;
}
inline const std::string& Credentials::_internal_mv() const {
  return mv_.Get();
}
inline void Credentials::_internal_set_mv(const std::string& value) {
  
  mv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Credentials::_internal_mutable_mv() {
  
  return mv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Credentials::release_mv() {
  // @@protoc_insertion_point(field_release:mgp.Credentials.mv)
  return mv_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Credentials::set_allocated_mv(std::string* mv) {
  if (mv != nullptr) {
    
  } else {
    
  }
  mv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mv,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Credentials.mv)
}

// -------------------------------------------------------------------

// User

// uint64 id = 1;
inline void User::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 User::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 User::id() const {
  // @@protoc_insertion_point(field_get:mgp.User.id)
  return _internal_id();
}
inline void User::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void User::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.User.id)
}

// string cn = 2;
inline void User::clear_cn() {
  cn_.ClearToEmpty();
}
inline const std::string& User::cn() const {
  // @@protoc_insertion_point(field_get:mgp.User.cn)
  return _internal_cn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_cn(ArgT0&& arg0, ArgT... args) {
 
 cn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.User.cn)
}
inline std::string* User::mutable_cn() {
  std::string* _s = _internal_mutable_cn();
  // @@protoc_insertion_point(field_mutable:mgp.User.cn)
  return _s;
}
inline const std::string& User::_internal_cn() const {
  return cn_.Get();
}
inline void User::_internal_set_cn(const std::string& value) {
  
  cn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_cn() {
  
  return cn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_cn() {
  // @@protoc_insertion_point(field_release:mgp.User.cn)
  return cn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_cn(std::string* cn) {
  if (cn != nullptr) {
    
  } else {
    
  }
  cn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cn,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.User.cn)
}

// .mgp.Credentials credentials = 3;
inline bool User::_internal_has_credentials() const {
  return this != internal_default_instance() && credentials_ != nullptr;
}
inline bool User::has_credentials() const {
  return _internal_has_credentials();
}
inline void User::clear_credentials() {
  if (GetArenaForAllocation() == nullptr && credentials_ != nullptr) {
    delete credentials_;
  }
  credentials_ = nullptr;
}
inline const ::mgp::Credentials& User::_internal_credentials() const {
  const ::mgp::Credentials* p = credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::Credentials&>(
      ::mgp::_Credentials_default_instance_);
}
inline const ::mgp::Credentials& User::credentials() const {
  // @@protoc_insertion_point(field_get:mgp.User.credentials)
  return _internal_credentials();
}
inline void User::unsafe_arena_set_allocated_credentials(
    ::mgp::Credentials* credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(credentials_);
  }
  credentials_ = credentials;
  if (credentials) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.User.credentials)
}
inline ::mgp::Credentials* User::release_credentials() {
  
  ::mgp::Credentials* temp = credentials_;
  credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::Credentials* User::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:mgp.User.credentials)
  
  ::mgp::Credentials* temp = credentials_;
  credentials_ = nullptr;
  return temp;
}
inline ::mgp::Credentials* User::_internal_mutable_credentials() {
  
  if (credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::Credentials>(GetArenaForAllocation());
    credentials_ = p;
  }
  return credentials_;
}
inline ::mgp::Credentials* User::mutable_credentials() {
  ::mgp::Credentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:mgp.User.credentials)
  return _msg;
}
inline void User::set_allocated_credentials(::mgp::Credentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete credentials_;
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::Credentials>::GetOwningArena(credentials);
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:mgp.User.credentials)
}

// uint32 role = 4;
inline void User::clear_role() {
  role_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 User::_internal_role() const {
  return role_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 User::role() const {
  // @@protoc_insertion_point(field_get:mgp.User.role)
  return _internal_role();
}
inline void User::_internal_set_role(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  role_ = value;
}
inline void User::set_role(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:mgp.User.role)
}

// -------------------------------------------------------------------

// MediaFile

// uint64 id = 1;
inline void MediaFile::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MediaFile::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MediaFile::id() const {
  // @@protoc_insertion_point(field_get:mgp.MediaFile.id)
  return _internal_id();
}
inline void MediaFile::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void MediaFile::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.MediaFile.id)
}

// string content_type = 2;
inline void MediaFile::clear_content_type() {
  content_type_.ClearToEmpty();
}
inline const std::string& MediaFile::content_type() const {
  // @@protoc_insertion_point(field_get:mgp.MediaFile.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediaFile::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.MediaFile.content_type)
}
inline std::string* MediaFile::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:mgp.MediaFile.content_type)
  return _s;
}
inline const std::string& MediaFile::_internal_content_type() const {
  return content_type_.Get();
}
inline void MediaFile::_internal_set_content_type(const std::string& value) {
  
  content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MediaFile::_internal_mutable_content_type() {
  
  return content_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MediaFile::release_content_type() {
  // @@protoc_insertion_point(field_release:mgp.MediaFile.content_type)
  return content_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MediaFile::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  content_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.MediaFile.content_type)
}

// string uri = 3;
inline void MediaFile::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& MediaFile::uri() const {
  // @@protoc_insertion_point(field_get:mgp.MediaFile.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediaFile::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.MediaFile.uri)
}
inline std::string* MediaFile::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mgp.MediaFile.uri)
  return _s;
}
inline const std::string& MediaFile::_internal_uri() const {
  return uri_.Get();
}
inline void MediaFile::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MediaFile::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MediaFile::release_uri() {
  // @@protoc_insertion_point(field_release:mgp.MediaFile.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MediaFile::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.MediaFile.uri)
}

// uint64 content_length = 4;
inline void MediaFile::clear_content_length() {
  content_length_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MediaFile::_internal_content_length() const {
  return content_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MediaFile::content_length() const {
  // @@protoc_insertion_point(field_get:mgp.MediaFile.content_length)
  return _internal_content_length();
}
inline void MediaFile::_internal_set_content_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  content_length_ = value;
}
inline void MediaFile::set_content_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_content_length(value);
  // @@protoc_insertion_point(field_set:mgp.MediaFile.content_length)
}

// bytes data = 5;
inline void MediaFile::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& MediaFile::data() const {
  // @@protoc_insertion_point(field_get:mgp.MediaFile.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediaFile::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.MediaFile.data)
}
inline std::string* MediaFile::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mgp.MediaFile.data)
  return _s;
}
inline const std::string& MediaFile::_internal_data() const {
  return data_.Get();
}
inline void MediaFile::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MediaFile::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MediaFile::release_data() {
  // @@protoc_insertion_point(field_release:mgp.MediaFile.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MediaFile::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.MediaFile.data)
}

// uint32 tag = 6;
inline void MediaFile::clear_tag() {
  tag_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaFile::_internal_tag() const {
  return tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaFile::tag() const {
  // @@protoc_insertion_point(field_get:mgp.MediaFile.tag)
  return _internal_tag();
}
inline void MediaFile::_internal_set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tag_ = value;
}
inline void MediaFile::set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:mgp.MediaFile.tag)
}

// -------------------------------------------------------------------

// Person

// uint64 id = 1;
inline void Person::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Person::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Person::id() const {
  // @@protoc_insertion_point(field_get:mgp.Person.id)
  return _internal_id();
}
inline void Person::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Person::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.Person.id)
}

// string first_name = 2;
inline void Person::clear_first_name() {
  first_name_.ClearToEmpty();
}
inline const std::string& Person::first_name() const {
  // @@protoc_insertion_point(field_get:mgp.Person.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_first_name(ArgT0&& arg0, ArgT... args) {
 
 first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.first_name)
}
inline std::string* Person::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:mgp.Person.first_name)
  return _s;
}
inline const std::string& Person::_internal_first_name() const {
  return first_name_.Get();
}
inline void Person::_internal_set_first_name(const std::string& value) {
  
  first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_first_name() {
  
  return first_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_first_name() {
  // @@protoc_insertion_point(field_release:mgp.Person.first_name)
  return first_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    
  } else {
    
  }
  first_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.first_name)
}

// string last_name = 3;
inline void Person::clear_last_name() {
  last_name_.ClearToEmpty();
}
inline const std::string& Person::last_name() const {
  // @@protoc_insertion_point(field_get:mgp.Person.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_last_name(ArgT0&& arg0, ArgT... args) {
 
 last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.last_name)
}
inline std::string* Person::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:mgp.Person.last_name)
  return _s;
}
inline const std::string& Person::_internal_last_name() const {
  return last_name_.Get();
}
inline void Person::_internal_set_last_name(const std::string& value) {
  
  last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_last_name() {
  
  return last_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_last_name() {
  // @@protoc_insertion_point(field_release:mgp.Person.last_name)
  return last_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    
  } else {
    
  }
  last_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.last_name)
}

// string middle_name = 4;
inline void Person::clear_middle_name() {
  middle_name_.ClearToEmpty();
}
inline const std::string& Person::middle_name() const {
  // @@protoc_insertion_point(field_get:mgp.Person.middle_name)
  return _internal_middle_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_middle_name(ArgT0&& arg0, ArgT... args) {
 
 middle_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.middle_name)
}
inline std::string* Person::mutable_middle_name() {
  std::string* _s = _internal_mutable_middle_name();
  // @@protoc_insertion_point(field_mutable:mgp.Person.middle_name)
  return _s;
}
inline const std::string& Person::_internal_middle_name() const {
  return middle_name_.Get();
}
inline void Person::_internal_set_middle_name(const std::string& value) {
  
  middle_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_middle_name() {
  
  return middle_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_middle_name() {
  // @@protoc_insertion_point(field_release:mgp.Person.middle_name)
  return middle_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_middle_name(std::string* middle_name) {
  if (middle_name != nullptr) {
    
  } else {
    
  }
  middle_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), middle_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.middle_name)
}

// string prefix = 5;
inline void Person::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& Person::prefix() const {
  // @@protoc_insertion_point(field_get:mgp.Person.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.prefix)
}
inline std::string* Person::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:mgp.Person.prefix)
  return _s;
}
inline const std::string& Person::_internal_prefix() const {
  return prefix_.Get();
}
inline void Person::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_prefix() {
  // @@protoc_insertion_point(field_release:mgp.Person.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.prefix)
}

// uint32 birthday = 6;
inline void Person::clear_birthday() {
  birthday_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Person::_internal_birthday() const {
  return birthday_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Person::birthday() const {
  // @@protoc_insertion_point(field_get:mgp.Person.birthday)
  return _internal_birthday();
}
inline void Person::_internal_set_birthday(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  birthday_ = value;
}
inline void Person::set_birthday(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_birthday(value);
  // @@protoc_insertion_point(field_set:mgp.Person.birthday)
}

// string document_type = 7;
inline void Person::clear_document_type() {
  document_type_.ClearToEmpty();
}
inline const std::string& Person::document_type() const {
  // @@protoc_insertion_point(field_get:mgp.Person.document_type)
  return _internal_document_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_document_type(ArgT0&& arg0, ArgT... args) {
 
 document_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.document_type)
}
inline std::string* Person::mutable_document_type() {
  std::string* _s = _internal_mutable_document_type();
  // @@protoc_insertion_point(field_mutable:mgp.Person.document_type)
  return _s;
}
inline const std::string& Person::_internal_document_type() const {
  return document_type_.Get();
}
inline void Person::_internal_set_document_type(const std::string& value) {
  
  document_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_document_type() {
  
  return document_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_document_type() {
  // @@protoc_insertion_point(field_release:mgp.Person.document_type)
  return document_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_document_type(std::string* document_type) {
  if (document_type != nullptr) {
    
  } else {
    
  }
  document_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), document_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.document_type)
}

// string document = 8;
inline void Person::clear_document() {
  document_.ClearToEmpty();
}
inline const std::string& Person::document() const {
  // @@protoc_insertion_point(field_get:mgp.Person.document)
  return _internal_document();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_document(ArgT0&& arg0, ArgT... args) {
 
 document_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.document)
}
inline std::string* Person::mutable_document() {
  std::string* _s = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:mgp.Person.document)
  return _s;
}
inline const std::string& Person::_internal_document() const {
  return document_.Get();
}
inline void Person::_internal_set_document(const std::string& value) {
  
  document_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_document() {
  
  return document_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_document() {
  // @@protoc_insertion_point(field_release:mgp.Person.document)
  return document_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_document(std::string* document) {
  if (document != nullptr) {
    
  } else {
    
  }
  document_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), document,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.document)
}

// string phone_mobile = 9;
inline void Person::clear_phone_mobile() {
  phone_mobile_.ClearToEmpty();
}
inline const std::string& Person::phone_mobile() const {
  // @@protoc_insertion_point(field_get:mgp.Person.phone_mobile)
  return _internal_phone_mobile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_phone_mobile(ArgT0&& arg0, ArgT... args) {
 
 phone_mobile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.phone_mobile)
}
inline std::string* Person::mutable_phone_mobile() {
  std::string* _s = _internal_mutable_phone_mobile();
  // @@protoc_insertion_point(field_mutable:mgp.Person.phone_mobile)
  return _s;
}
inline const std::string& Person::_internal_phone_mobile() const {
  return phone_mobile_.Get();
}
inline void Person::_internal_set_phone_mobile(const std::string& value) {
  
  phone_mobile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_phone_mobile() {
  
  return phone_mobile_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_phone_mobile() {
  // @@protoc_insertion_point(field_release:mgp.Person.phone_mobile)
  return phone_mobile_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_phone_mobile(std::string* phone_mobile) {
  if (phone_mobile != nullptr) {
    
  } else {
    
  }
  phone_mobile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone_mobile,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.phone_mobile)
}

// string email = 10;
inline void Person::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& Person::email() const {
  // @@protoc_insertion_point(field_get:mgp.Person.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Person::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Person.email)
}
inline std::string* Person::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:mgp.Person.email)
  return _s;
}
inline const std::string& Person::_internal_email() const {
  return email_.Get();
}
inline void Person::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Person::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Person::release_email() {
  // @@protoc_insertion_point(field_release:mgp.Person.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Person::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Person.email)
}

// uint32 gender = 11;
inline void Person::clear_gender() {
  gender_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Person::_internal_gender() const {
  return gender_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Person::gender() const {
  // @@protoc_insertion_point(field_get:mgp.Person.gender)
  return _internal_gender();
}
inline void Person::_internal_set_gender(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  gender_ = value;
}
inline void Person::set_gender(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:mgp.Person.gender)
}

// uint32 tag = 12;
inline void Person::clear_tag() {
  tag_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Person::_internal_tag() const {
  return tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Person::tag() const {
  // @@protoc_insertion_point(field_get:mgp.Person.tag)
  return _internal_tag();
}
inline void Person::_internal_set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tag_ = value;
}
inline void Person::set_tag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:mgp.Person.tag)
}

// repeated .mgp.MediaFile medias = 13;
inline int Person::_internal_medias_size() const {
  return medias_.size();
}
inline int Person::medias_size() const {
  return _internal_medias_size();
}
inline void Person::clear_medias() {
  medias_.Clear();
}
inline ::mgp::MediaFile* Person::mutable_medias(int index) {
  // @@protoc_insertion_point(field_mutable:mgp.Person.medias)
  return medias_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
Person::mutable_medias() {
  // @@protoc_insertion_point(field_mutable_list:mgp.Person.medias)
  return &medias_;
}
inline const ::mgp::MediaFile& Person::_internal_medias(int index) const {
  return medias_.Get(index);
}
inline const ::mgp::MediaFile& Person::medias(int index) const {
  // @@protoc_insertion_point(field_get:mgp.Person.medias)
  return _internal_medias(index);
}
inline ::mgp::MediaFile* Person::_internal_add_medias() {
  return medias_.Add();
}
inline ::mgp::MediaFile* Person::add_medias() {
  ::mgp::MediaFile* _add = _internal_add_medias();
  // @@protoc_insertion_point(field_add:mgp.Person.medias)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
Person::medias() const {
  // @@protoc_insertion_point(field_list:mgp.Person.medias)
  return medias_;
}

// -------------------------------------------------------------------

// Employee

// uint64 id = 1;
inline void Employee::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Employee::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Employee::id() const {
  // @@protoc_insertion_point(field_get:mgp.Employee.id)
  return _internal_id();
}
inline void Employee::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Employee::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.Employee.id)
}

// uint32 role_number = 2;
inline void Employee::clear_role_number() {
  role_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Employee::_internal_role_number() const {
  return role_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Employee::role_number() const {
  // @@protoc_insertion_point(field_get:mgp.Employee.role_number)
  return _internal_role_number();
}
inline void Employee::_internal_set_role_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  role_number_ = value;
}
inline void Employee::set_role_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_role_number(value);
  // @@protoc_insertion_point(field_set:mgp.Employee.role_number)
}

// string name = 3;
inline void Employee::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Employee::name() const {
  // @@protoc_insertion_point(field_get:mgp.Employee.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Employee::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Employee.name)
}
inline std::string* Employee::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mgp.Employee.name)
  return _s;
}
inline const std::string& Employee::_internal_name() const {
  return name_.Get();
}
inline void Employee::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Employee::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Employee::release_name() {
  // @@protoc_insertion_point(field_release:mgp.Employee.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Employee::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Employee.name)
}

// .mgp.Person person = 4;
inline bool Employee::_internal_has_person() const {
  return this != internal_default_instance() && person_ != nullptr;
}
inline bool Employee::has_person() const {
  return _internal_has_person();
}
inline void Employee::clear_person() {
  if (GetArenaForAllocation() == nullptr && person_ != nullptr) {
    delete person_;
  }
  person_ = nullptr;
}
inline const ::mgp::Person& Employee::_internal_person() const {
  const ::mgp::Person* p = person_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::Person&>(
      ::mgp::_Person_default_instance_);
}
inline const ::mgp::Person& Employee::person() const {
  // @@protoc_insertion_point(field_get:mgp.Employee.person)
  return _internal_person();
}
inline void Employee::unsafe_arena_set_allocated_person(
    ::mgp::Person* person) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(person_);
  }
  person_ = person;
  if (person) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.Employee.person)
}
inline ::mgp::Person* Employee::release_person() {
  
  ::mgp::Person* temp = person_;
  person_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::Person* Employee::unsafe_arena_release_person() {
  // @@protoc_insertion_point(field_release:mgp.Employee.person)
  
  ::mgp::Person* temp = person_;
  person_ = nullptr;
  return temp;
}
inline ::mgp::Person* Employee::_internal_mutable_person() {
  
  if (person_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::Person>(GetArenaForAllocation());
    person_ = p;
  }
  return person_;
}
inline ::mgp::Person* Employee::mutable_person() {
  ::mgp::Person* _msg = _internal_mutable_person();
  // @@protoc_insertion_point(field_mutable:mgp.Employee.person)
  return _msg;
}
inline void Employee::set_allocated_person(::mgp::Person* person) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete person_;
  }
  if (person) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::Person>::GetOwningArena(person);
    if (message_arena != submessage_arena) {
      person = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, person, submessage_arena);
    }
    
  } else {
    
  }
  person_ = person;
  // @@protoc_insertion_point(field_set_allocated:mgp.Employee.person)
}

// .mgp.User user = 5;
inline bool Employee::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool Employee::has_user() const {
  return _internal_has_user();
}
inline void Employee::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::mgp::User& Employee::_internal_user() const {
  const ::mgp::User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::User&>(
      ::mgp::_User_default_instance_);
}
inline const ::mgp::User& Employee::user() const {
  // @@protoc_insertion_point(field_get:mgp.Employee.user)
  return _internal_user();
}
inline void Employee::unsafe_arena_set_allocated_user(
    ::mgp::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.Employee.user)
}
inline ::mgp::User* Employee::release_user() {
  
  ::mgp::User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::User* Employee::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:mgp.Employee.user)
  
  ::mgp::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::mgp::User* Employee::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::mgp::User* Employee::mutable_user() {
  ::mgp::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:mgp.Employee.user)
  return _msg;
}
inline void Employee::set_allocated_user(::mgp::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:mgp.Employee.user)
}

// repeated .mgp.MediaFile medias = 6;
inline int Employee::_internal_medias_size() const {
  return medias_.size();
}
inline int Employee::medias_size() const {
  return _internal_medias_size();
}
inline void Employee::clear_medias() {
  medias_.Clear();
}
inline ::mgp::MediaFile* Employee::mutable_medias(int index) {
  // @@protoc_insertion_point(field_mutable:mgp.Employee.medias)
  return medias_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
Employee::mutable_medias() {
  // @@protoc_insertion_point(field_mutable_list:mgp.Employee.medias)
  return &medias_;
}
inline const ::mgp::MediaFile& Employee::_internal_medias(int index) const {
  return medias_.Get(index);
}
inline const ::mgp::MediaFile& Employee::medias(int index) const {
  // @@protoc_insertion_point(field_get:mgp.Employee.medias)
  return _internal_medias(index);
}
inline ::mgp::MediaFile* Employee::_internal_add_medias() {
  return medias_.Add();
}
inline ::mgp::MediaFile* Employee::add_medias() {
  ::mgp::MediaFile* _add = _internal_add_medias();
  // @@protoc_insertion_point(field_add:mgp.Employee.medias)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
Employee::medias() const {
  // @@protoc_insertion_point(field_list:mgp.Employee.medias)
  return medias_;
}

// -------------------------------------------------------------------

// Org

// uint64 id = 1;
inline void Org::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Org::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Org::id() const {
  // @@protoc_insertion_point(field_get:mgp.Org.id)
  return _internal_id();
}
inline void Org::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Org::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.Org.id)
}

// string name = 2;
inline void Org::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Org::name() const {
  // @@protoc_insertion_point(field_get:mgp.Org.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Org::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Org.name)
}
inline std::string* Org::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mgp.Org.name)
  return _s;
}
inline const std::string& Org::_internal_name() const {
  return name_.Get();
}
inline void Org::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Org::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Org::release_name() {
  // @@protoc_insertion_point(field_release:mgp.Org.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Org::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Org.name)
}

// .mgp.Employee manager = 3;
inline bool Org::_internal_has_manager() const {
  return this != internal_default_instance() && manager_ != nullptr;
}
inline bool Org::has_manager() const {
  return _internal_has_manager();
}
inline void Org::clear_manager() {
  if (GetArenaForAllocation() == nullptr && manager_ != nullptr) {
    delete manager_;
  }
  manager_ = nullptr;
}
inline const ::mgp::Employee& Org::_internal_manager() const {
  const ::mgp::Employee* p = manager_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::Employee&>(
      ::mgp::_Employee_default_instance_);
}
inline const ::mgp::Employee& Org::manager() const {
  // @@protoc_insertion_point(field_get:mgp.Org.manager)
  return _internal_manager();
}
inline void Org::unsafe_arena_set_allocated_manager(
    ::mgp::Employee* manager) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(manager_);
  }
  manager_ = manager;
  if (manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.Org.manager)
}
inline ::mgp::Employee* Org::release_manager() {
  
  ::mgp::Employee* temp = manager_;
  manager_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::Employee* Org::unsafe_arena_release_manager() {
  // @@protoc_insertion_point(field_release:mgp.Org.manager)
  
  ::mgp::Employee* temp = manager_;
  manager_ = nullptr;
  return temp;
}
inline ::mgp::Employee* Org::_internal_mutable_manager() {
  
  if (manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::Employee>(GetArenaForAllocation());
    manager_ = p;
  }
  return manager_;
}
inline ::mgp::Employee* Org::mutable_manager() {
  ::mgp::Employee* _msg = _internal_mutable_manager();
  // @@protoc_insertion_point(field_mutable:mgp.Org.manager)
  return _msg;
}
inline void Org::set_allocated_manager(::mgp::Employee* manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete manager_;
  }
  if (manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::Employee>::GetOwningArena(manager);
    if (message_arena != submessage_arena) {
      manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manager, submessage_arena);
    }
    
  } else {
    
  }
  manager_ = manager;
  // @@protoc_insertion_point(field_set_allocated:mgp.Org.manager)
}

// repeated .mgp.MediaFile medias = 4;
inline int Org::_internal_medias_size() const {
  return medias_.size();
}
inline int Org::medias_size() const {
  return _internal_medias_size();
}
inline void Org::clear_medias() {
  medias_.Clear();
}
inline ::mgp::MediaFile* Org::mutable_medias(int index) {
  // @@protoc_insertion_point(field_mutable:mgp.Org.medias)
  return medias_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
Org::mutable_medias() {
  // @@protoc_insertion_point(field_mutable_list:mgp.Org.medias)
  return &medias_;
}
inline const ::mgp::MediaFile& Org::_internal_medias(int index) const {
  return medias_.Get(index);
}
inline const ::mgp::MediaFile& Org::medias(int index) const {
  // @@protoc_insertion_point(field_get:mgp.Org.medias)
  return _internal_medias(index);
}
inline ::mgp::MediaFile* Org::_internal_add_medias() {
  return medias_.Add();
}
inline ::mgp::MediaFile* Org::add_medias() {
  ::mgp::MediaFile* _add = _internal_add_medias();
  // @@protoc_insertion_point(field_add:mgp.Org.medias)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
Org::medias() const {
  // @@protoc_insertion_point(field_list:mgp.Org.medias)
  return medias_;
}

// -------------------------------------------------------------------

// Inventory

// uint64 id = 1;
inline void Inventory::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Inventory::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Inventory::id() const {
  // @@protoc_insertion_point(field_get:mgp.Inventory.id)
  return _internal_id();
}
inline void Inventory::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Inventory::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mgp.Inventory.id)
}

// .mgp.Org org = 2;
inline bool Inventory::_internal_has_org() const {
  return this != internal_default_instance() && org_ != nullptr;
}
inline bool Inventory::has_org() const {
  return _internal_has_org();
}
inline void Inventory::clear_org() {
  if (GetArenaForAllocation() == nullptr && org_ != nullptr) {
    delete org_;
  }
  org_ = nullptr;
}
inline const ::mgp::Org& Inventory::_internal_org() const {
  const ::mgp::Org* p = org_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::Org&>(
      ::mgp::_Org_default_instance_);
}
inline const ::mgp::Org& Inventory::org() const {
  // @@protoc_insertion_point(field_get:mgp.Inventory.org)
  return _internal_org();
}
inline void Inventory::unsafe_arena_set_allocated_org(
    ::mgp::Org* org) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(org_);
  }
  org_ = org;
  if (org) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.Inventory.org)
}
inline ::mgp::Org* Inventory::release_org() {
  
  ::mgp::Org* temp = org_;
  org_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::Org* Inventory::unsafe_arena_release_org() {
  // @@protoc_insertion_point(field_release:mgp.Inventory.org)
  
  ::mgp::Org* temp = org_;
  org_ = nullptr;
  return temp;
}
inline ::mgp::Org* Inventory::_internal_mutable_org() {
  
  if (org_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::Org>(GetArenaForAllocation());
    org_ = p;
  }
  return org_;
}
inline ::mgp::Org* Inventory::mutable_org() {
  ::mgp::Org* _msg = _internal_mutable_org();
  // @@protoc_insertion_point(field_mutable:mgp.Inventory.org)
  return _msg;
}
inline void Inventory::set_allocated_org(::mgp::Org* org) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete org_;
  }
  if (org) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::Org>::GetOwningArena(org);
    if (message_arena != submessage_arena) {
      org = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, org, submessage_arena);
    }
    
  } else {
    
  }
  org_ = org;
  // @@protoc_insertion_point(field_set_allocated:mgp.Inventory.org)
}

// uint64 inventory_number = 3;
inline void Inventory::clear_inventory_number() {
  inventory_number_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Inventory::_internal_inventory_number() const {
  return inventory_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Inventory::inventory_number() const {
  // @@protoc_insertion_point(field_get:mgp.Inventory.inventory_number)
  return _internal_inventory_number();
}
inline void Inventory::_internal_set_inventory_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  inventory_number_ = value;
}
inline void Inventory::set_inventory_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_inventory_number(value);
  // @@protoc_insertion_point(field_set:mgp.Inventory.inventory_number)
}

// string name = 4;
inline void Inventory::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Inventory::name() const {
  // @@protoc_insertion_point(field_get:mgp.Inventory.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Inventory::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mgp.Inventory.name)
}
inline std::string* Inventory::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mgp.Inventory.name)
  return _s;
}
inline const std::string& Inventory::_internal_name() const {
  return name_.Get();
}
inline void Inventory::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Inventory::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Inventory::release_name() {
  // @@protoc_insertion_point(field_release:mgp.Inventory.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Inventory::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mgp.Inventory.name)
}

// repeated .mgp.MediaFile medias = 5;
inline int Inventory::_internal_medias_size() const {
  return medias_.size();
}
inline int Inventory::medias_size() const {
  return _internal_medias_size();
}
inline void Inventory::clear_medias() {
  medias_.Clear();
}
inline ::mgp::MediaFile* Inventory::mutable_medias(int index) {
  // @@protoc_insertion_point(field_mutable:mgp.Inventory.medias)
  return medias_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >*
Inventory::mutable_medias() {
  // @@protoc_insertion_point(field_mutable_list:mgp.Inventory.medias)
  return &medias_;
}
inline const ::mgp::MediaFile& Inventory::_internal_medias(int index) const {
  return medias_.Get(index);
}
inline const ::mgp::MediaFile& Inventory::medias(int index) const {
  // @@protoc_insertion_point(field_get:mgp.Inventory.medias)
  return _internal_medias(index);
}
inline ::mgp::MediaFile* Inventory::_internal_add_medias() {
  return medias_.Add();
}
inline ::mgp::MediaFile* Inventory::add_medias() {
  ::mgp::MediaFile* _add = _internal_add_medias();
  // @@protoc_insertion_point(field_add:mgp.Inventory.medias)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::MediaFile >&
Inventory::medias() const {
  // @@protoc_insertion_point(field_list:mgp.Inventory.medias)
  return medias_;
}

// -------------------------------------------------------------------

// InventoryListRequest

// .mgp.Inventory inventory = 1;
inline bool InventoryListRequest::_internal_has_inventory() const {
  return this != internal_default_instance() && inventory_ != nullptr;
}
inline bool InventoryListRequest::has_inventory() const {
  return _internal_has_inventory();
}
inline void InventoryListRequest::clear_inventory() {
  if (GetArenaForAllocation() == nullptr && inventory_ != nullptr) {
    delete inventory_;
  }
  inventory_ = nullptr;
}
inline const ::mgp::Inventory& InventoryListRequest::_internal_inventory() const {
  const ::mgp::Inventory* p = inventory_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::Inventory&>(
      ::mgp::_Inventory_default_instance_);
}
inline const ::mgp::Inventory& InventoryListRequest::inventory() const {
  // @@protoc_insertion_point(field_get:mgp.InventoryListRequest.inventory)
  return _internal_inventory();
}
inline void InventoryListRequest::unsafe_arena_set_allocated_inventory(
    ::mgp::Inventory* inventory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inventory_);
  }
  inventory_ = inventory;
  if (inventory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.InventoryListRequest.inventory)
}
inline ::mgp::Inventory* InventoryListRequest::release_inventory() {
  
  ::mgp::Inventory* temp = inventory_;
  inventory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::Inventory* InventoryListRequest::unsafe_arena_release_inventory() {
  // @@protoc_insertion_point(field_release:mgp.InventoryListRequest.inventory)
  
  ::mgp::Inventory* temp = inventory_;
  inventory_ = nullptr;
  return temp;
}
inline ::mgp::Inventory* InventoryListRequest::_internal_mutable_inventory() {
  
  if (inventory_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::Inventory>(GetArenaForAllocation());
    inventory_ = p;
  }
  return inventory_;
}
inline ::mgp::Inventory* InventoryListRequest::mutable_inventory() {
  ::mgp::Inventory* _msg = _internal_mutable_inventory();
  // @@protoc_insertion_point(field_mutable:mgp.InventoryListRequest.inventory)
  return _msg;
}
inline void InventoryListRequest::set_allocated_inventory(::mgp::Inventory* inventory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inventory_;
  }
  if (inventory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::Inventory>::GetOwningArena(inventory);
    if (message_arena != submessage_arena) {
      inventory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inventory, submessage_arena);
    }
    
  } else {
    
  }
  inventory_ = inventory;
  // @@protoc_insertion_point(field_set_allocated:mgp.InventoryListRequest.inventory)
}

// .mgp.ListRequest listrequest = 2;
inline bool InventoryListRequest::_internal_has_listrequest() const {
  return this != internal_default_instance() && listrequest_ != nullptr;
}
inline bool InventoryListRequest::has_listrequest() const {
  return _internal_has_listrequest();
}
inline void InventoryListRequest::clear_listrequest() {
  if (GetArenaForAllocation() == nullptr && listrequest_ != nullptr) {
    delete listrequest_;
  }
  listrequest_ = nullptr;
}
inline const ::mgp::ListRequest& InventoryListRequest::_internal_listrequest() const {
  const ::mgp::ListRequest* p = listrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::ListRequest&>(
      ::mgp::_ListRequest_default_instance_);
}
inline const ::mgp::ListRequest& InventoryListRequest::listrequest() const {
  // @@protoc_insertion_point(field_get:mgp.InventoryListRequest.listrequest)
  return _internal_listrequest();
}
inline void InventoryListRequest::unsafe_arena_set_allocated_listrequest(
    ::mgp::ListRequest* listrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(listrequest_);
  }
  listrequest_ = listrequest;
  if (listrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.InventoryListRequest.listrequest)
}
inline ::mgp::ListRequest* InventoryListRequest::release_listrequest() {
  
  ::mgp::ListRequest* temp = listrequest_;
  listrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::ListRequest* InventoryListRequest::unsafe_arena_release_listrequest() {
  // @@protoc_insertion_point(field_release:mgp.InventoryListRequest.listrequest)
  
  ::mgp::ListRequest* temp = listrequest_;
  listrequest_ = nullptr;
  return temp;
}
inline ::mgp::ListRequest* InventoryListRequest::_internal_mutable_listrequest() {
  
  if (listrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::ListRequest>(GetArenaForAllocation());
    listrequest_ = p;
  }
  return listrequest_;
}
inline ::mgp::ListRequest* InventoryListRequest::mutable_listrequest() {
  ::mgp::ListRequest* _msg = _internal_mutable_listrequest();
  // @@protoc_insertion_point(field_mutable:mgp.InventoryListRequest.listrequest)
  return _msg;
}
inline void InventoryListRequest::set_allocated_listrequest(::mgp::ListRequest* listrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete listrequest_;
  }
  if (listrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::ListRequest>::GetOwningArena(listrequest);
    if (message_arena != submessage_arena) {
      listrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, listrequest, submessage_arena);
    }
    
  } else {
    
  }
  listrequest_ = listrequest;
  // @@protoc_insertion_point(field_set_allocated:mgp.InventoryListRequest.listrequest)
}

// -------------------------------------------------------------------

// InventoryListResponse

// .mgp.OperationResponse response = 1;
inline bool InventoryListResponse::_internal_has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline bool InventoryListResponse::has_response() const {
  return _internal_has_response();
}
inline void InventoryListResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::mgp::OperationResponse& InventoryListResponse::_internal_response() const {
  const ::mgp::OperationResponse* p = response_;
  return p != nullptr ? *p : reinterpret_cast<const ::mgp::OperationResponse&>(
      ::mgp::_OperationResponse_default_instance_);
}
inline const ::mgp::OperationResponse& InventoryListResponse::response() const {
  // @@protoc_insertion_point(field_get:mgp.InventoryListResponse.response)
  return _internal_response();
}
inline void InventoryListResponse::unsafe_arena_set_allocated_response(
    ::mgp::OperationResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mgp.InventoryListResponse.response)
}
inline ::mgp::OperationResponse* InventoryListResponse::release_response() {
  
  ::mgp::OperationResponse* temp = response_;
  response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mgp::OperationResponse* InventoryListResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:mgp.InventoryListResponse.response)
  
  ::mgp::OperationResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::mgp::OperationResponse* InventoryListResponse::_internal_mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::mgp::OperationResponse>(GetArenaForAllocation());
    response_ = p;
  }
  return response_;
}
inline ::mgp::OperationResponse* InventoryListResponse::mutable_response() {
  ::mgp::OperationResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:mgp.InventoryListResponse.response)
  return _msg;
}
inline void InventoryListResponse::set_allocated_response(::mgp::OperationResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mgp::OperationResponse>::GetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:mgp.InventoryListResponse.response)
}

// repeated .mgp.Inventory inventory = 2;
inline int InventoryListResponse::_internal_inventory_size() const {
  return inventory_.size();
}
inline int InventoryListResponse::inventory_size() const {
  return _internal_inventory_size();
}
inline void InventoryListResponse::clear_inventory() {
  inventory_.Clear();
}
inline ::mgp::Inventory* InventoryListResponse::mutable_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:mgp.InventoryListResponse.inventory)
  return inventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Inventory >*
InventoryListResponse::mutable_inventory() {
  // @@protoc_insertion_point(field_mutable_list:mgp.InventoryListResponse.inventory)
  return &inventory_;
}
inline const ::mgp::Inventory& InventoryListResponse::_internal_inventory(int index) const {
  return inventory_.Get(index);
}
inline const ::mgp::Inventory& InventoryListResponse::inventory(int index) const {
  // @@protoc_insertion_point(field_get:mgp.InventoryListResponse.inventory)
  return _internal_inventory(index);
}
inline ::mgp::Inventory* InventoryListResponse::_internal_add_inventory() {
  return inventory_.Add();
}
inline ::mgp::Inventory* InventoryListResponse::add_inventory() {
  ::mgp::Inventory* _add = _internal_add_inventory();
  // @@protoc_insertion_point(field_add:mgp.InventoryListResponse.inventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mgp::Inventory >&
InventoryListResponse::inventory() const {
  // @@protoc_insertion_point(field_list:mgp.InventoryListResponse.inventory)
  return inventory_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mgp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mgp_2eproto
